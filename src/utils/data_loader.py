import os
import re
from glob import glob
from typing import List, Optional

import pandas as pd


def list_data_files(
    data_dir: str = "data",
    symbol_filter: Optional[str] = None,
) -> List[str]:
    """
    List CSV files in the data directory.
    Optionally filter by symbol substring, e.g. 'BTC_USD'.
    """
    pattern = os.path.join(data_dir, "*.csv")
    files = glob(pattern)

    if symbol_filter:
        files = [f for f in files if symbol_filter in os.path.basename(f)]

    return sorted(files)


def _pick_latest_symbol_file(files: List[str], symbol_filter: Optional[str]) -> Optional[str]:
    """
    Prefer the latest timestamped file like BTC_USD_YYYYMMDD_HHMMSS.csv.
    Falls back to the last sorted match if pattern isn't present.
    """
    if not files:
        return None

    if not symbol_filter:
        # No symbol filter => keep previous behavior (combine all)
        return None

    # Match: SYMBOL_20251210_114738.csv
    # Capture groups: date(YYYYMMDD), time(HHMMSS)
    rx = re.compile(rf"^{re.escape(symbol_filter)}_(\d{{8}})_(\d{{6}})\.csv$")

    best = None
    best_key = None

    for path in files:
        name = os.path.basename(path)
        m = rx.match(name)
        if m:
            key = (m.group(1), m.group(2))  # (date, time) as strings, sortable
            if best_key is None or key > best_key:
                best_key = key
                best = path

    # If we found a timestamped file, use it; else fall back to last sorted match
    return best or files[-1]


def load_price_data(
    asset_or_symbol: Optional[str] = None,
    data_dir: str = "data",
    symbol_filter: Optional[str] = None,
) -> pd.DataFrame:
    """
    Load and clean CSVs generated by our yfinance ingestion.

    Accepts either:
      - load_price_data("BTC-USD")
      - load_price_data("BTC_USD")
      - load_price_data(symbol_filter="BTC_USD")

    Yahoo Finance crypto format includes:
      Row 1: column categories
      Row 2: ticker symbols
      Row 3: "timestamp,,,,,,"
      Row 4+: actual data
    """
    # âœ… Backwards-compatible: if caller passes asset like "BTC-USD", normalize it to "BTC_USD"
    if symbol_filter is None and asset_or_symbol:
        symbol_filter = str(asset_or_symbol).strip().upper().replace("-", "_")

    files = list_data_files(data_dir=data_dir, symbol_filter=symbol_filter)
    if not files:
        raise FileNotFoundError(
            f"No CSV files found in {data_dir} for filter={symbol_filter}"
        )

    # IMPORTANT: in Lambda, we typically want ONE latest file per symbol, not concatenating old snapshots.
    latest_path = _pick_latest_symbol_file(files, symbol_filter=symbol_filter)

    # If symbol_filter was provided, we load only the latest file (best for speed + correctness)
    # If symbol_filter is None, preserve prior behavior (combine all CSVs)
    paths_to_load = [latest_path] if (symbol_filter and latest_path) else files

    dfs = []
    for path in paths_to_load:
        df = pd.read_csv(
            path,
            skiprows=2,  # skip "Price,...", "Ticker,..."
            header=0,    # use the third row ("timestamp,,,,,,") as header
        )

        # Drop rows where timestamp literally equals "timestamp"
        df = df[df["timestamp"] != "timestamp"]

        # Clean column names
        df.columns = [
            "timestamp",
            "adj_close",
            "close",
            "high",
            "low",
            "open",
            "volume",
        ]

        # Convert timestamp to datetime
        df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")

        # Remove bad rows
        df = df.dropna(subset=["timestamp"])

        df = df.set_index("timestamp").sort_index()
        dfs.append(df)

    combined = pd.concat(dfs)
    combined = combined[~combined.index.duplicated(keep="last")]
    combined = combined.sort_index()
    return combined
